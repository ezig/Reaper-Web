"use strict";
var axis_1 = require("vega-lite/build/src/axis");
var scale_1 = require("vega-lite/build/src/scale");
var legend_1 = require("vega-lite/build/src/legend");
var util_1 = require("./util");
function isEncodingNestedProp(p) {
    return !!p['parent'];
}
exports.isEncodingNestedProp = isEncodingNestedProp;
exports.ENCODING_TOPLEVEL_PROPS = [
    // channel
    'channel',
    // fn
    'aggregate', 'autoCount', 'bin', 'timeUnit', 'hasFn',
    // sort
    'sort',
    // field / type
    'field', 'type',
    // scale / axis / legend
    'scale', 'axis', 'legend'
];
var ENCODING_TOPLEVEL_PROPERTY_INDEX = util_1.toMap(exports.ENCODING_TOPLEVEL_PROPS);
function isEncodingTopLevelProperty(p) {
    return p in ENCODING_TOPLEVEL_PROPERTY_INDEX;
}
exports.isEncodingTopLevelProperty = isEncodingTopLevelProperty;
var ENCODING_NESTED_PROP_PARENTS = [
    'bin', 'scale', 'sort', 'axis', 'legend'
];
var ENCODING_NESTED_PROP_PARENT_INDEX = util_1.toMap(ENCODING_NESTED_PROP_PARENTS);
function hasNestedProperty(prop) {
    return ENCODING_NESTED_PROP_PARENT_INDEX[prop];
}
exports.hasNestedProperty = hasNestedProperty;
exports.BIN_CHILD_PROPS = ['maxbins', 'divide', 'extent', 'base', 'step', 'steps', 'minstep'];
exports.SORT_CHILD_PROPS = ['field', 'op', 'order'];
exports.SCALE_CHILD_PROPS = ['clamp', 'domain', 'exponent', 'nice', 'range', 'rangeStep', 'round', 'type', 'zero'];
var BIN_PROPS = exports.BIN_CHILD_PROPS.map(function (c) {
    return { parent: 'bin', child: c };
});
exports.SORT_PROPS = exports.SORT_CHILD_PROPS.map(function (c) {
    return { parent: 'sort', child: c };
});
exports.SCALE_PROPS = scale_1.SCALE_PROPERTIES.map(function (c) {
    return { parent: 'scale', child: c };
});
var AXIS_PROPS = axis_1.AXIS_PROPERTIES.map(function (c) {
    return { parent: 'axis', child: c };
});
var LEGEND_PROPS = legend_1.LEGEND_PROPERTIES.map(function (c) {
    return { parent: 'legend', child: c };
});
exports.ENCODING_NESTED_PROPS = [].concat(BIN_PROPS, exports.SORT_PROPS, exports.SCALE_PROPS, AXIS_PROPS, LEGEND_PROPS);
var PROP_KEY_DELIMITER = '.';
function toKey(p) {
    if (isEncodingNestedProp(p)) {
        return p.parent + PROP_KEY_DELIMITER + p.child;
    }
    return p;
}
exports.toKey = toKey;
function fromKey(k) {
    var split = k.split(PROP_KEY_DELIMITER);
    /* istanbul ignore else */
    if (split.length === 1) {
        return k;
    }
    else if (split.length === 2) {
        return {
            parent: split[0],
            child: split[1]
        };
    }
    else {
        throw 'Invalid property key with ' + split.length + ' dots: ' + k;
    }
}
exports.fromKey = fromKey;
var ENCODING_NESTED_PROP_INDEX = exports.ENCODING_NESTED_PROPS.reduce(function (i, prop) {
    i[prop.parent] = i[prop.parent] || [];
    i[prop.parent][prop.child] = prop;
    return i;
}, {});
// FIXME consider using a more general method
function getEncodingNestedProp(parent, child) {
    return (ENCODING_NESTED_PROP_INDEX[parent] || {})[child];
}
exports.getEncodingNestedProp = getEncodingNestedProp;
function isEncodingProperty(prop) {
    return isEncodingTopLevelProperty(prop) || isEncodingNestedProp(prop);
}
exports.isEncodingProperty = isEncodingProperty;
exports.ALL_ENCODING_PROPS = [].concat(exports.ENCODING_TOPLEVEL_PROPS, exports.ENCODING_NESTED_PROPS);
exports.DEFAULT_PROP_PRECEDENCE = [
    'type',
    'field',
    // Field Transform
    'bin', 'timeUnit', 'aggregate', 'autoCount',
    // Encoding
    'channel',
    // Mark
    'mark',
    'scale', 'sort',
    'axis', 'legend'
].concat(BIN_PROPS, exports.SCALE_PROPS, AXIS_PROPS, LEGEND_PROPS, exports.SORT_PROPS);
var Property;
(function (Property) {
    Property.MARK = 'mark';
    Property.FILTER = 'filter';
    // TODO: Sub-properties for filter
    Property.CALCULATE = 'calculate';
    // TODO: Sub-properties for calculate
    Property.FILTERINVALID = 'filterInvalid';
    // Layout
    Property.STACK = 'stack';
    // TODO: sub parts of stack
    // Encoding Properties
    Property.CHANNEL = 'channel';
    Property.AGGREGATE = 'aggregate';
    Property.AUTOCOUNT = 'autoCount';
    Property.BIN = 'bin';
    Property.HAS_FN = 'hasFn';
    Property.TIMEUNIT = 'timeUnit';
    Property.FIELD = 'field';
    Property.TYPE = 'type';
    Property.SORT = 'sort';
    Property.SCALE = 'scale';
    Property.AXIS = 'axis';
    Property.LEGEND = 'legend';
})(Property = exports.Property || (exports.Property = {}));
//# sourceMappingURL=property.js.map